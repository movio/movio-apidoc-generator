/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 1.0.0
 */

import scala.util.{ Try, Failure }

import org.apache.kafka.clients.producer.KafkaProducer
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.common.serialization.StringSerializer

import play.api.libs.json.Json
import play.api.libs.json.Writes

import java.util.Properties
import com.typesafe.config.Config

import movio.api.kafka_0_10.Producer
import movio.api.kafka_0_10.KafkaProducerException
import movio.core.utils.TryHelpers.TryOps

package test.apidoc.apidoctest.v0.kafka {
  import test.apidoc.apidoctest.v0.models._
  import test.apidoc.apidoctest.v0.models.json._

  object KafkaMemberProducer {
    val base = "test.apidoc.apidoctest.kafka.producer"
    val BootstrapServers = s"$base.bootstrap.servers"
    val TopicInstanceKey = s"$base.topic.instance"
  }

  class KafkaMemberProducer(
    config: Config
  ) extends Producer[KafkaMember, Member] {
    import KafkaMemberProducer._

    lazy val topicResolver = KafkaMemberTopic.topic(config.getString(TopicInstanceKey))(_)

    lazy val kafkaProducer = new KafkaProducer[String, String](readProducerPropertiesFromConfig(config))

    def readProducerPropertiesFromConfig(config: Config) = {
      // Default linger to 500millis
      val lingerKey = "linger.ms"
      val lingerMs = if (config.hasPath(lingerKey)) config.getInt(lingerKey) else 500
      val properties = new Properties
      properties.put("producer.type", "sync")
      properties.put("bootstrap.servers", config.getString(BootstrapServers))
      properties.put("request.required.acks", "-1")
      properties.put("linger.ms", lingerMs.toString)
      properties.put("key.serializer", classOf[StringSerializer].getName)
      properties.put("value.serializer", classOf[StringSerializer].getName)
      properties
    }

    def send(single: Member, tenant: String): Try[Member] = {
      send(Seq(single), tenant).map(_.head)
    }

    def sendWrapped(single: KafkaMember, tenant: String): Try[KafkaMember] = {
      sendWrapped(Seq(single), tenant).map(_.head)
    }

    def send(batch: Seq[Member], tenant: String): Try[Seq[Member]] = {
      val topic = topicResolver(tenant)
      val messages = batch.map(KafkaMember(_))
      Try {
        messages foreach { record ⇒
          kafkaProducer.send(
            new ProducerRecord[String, String](topic, record.generateKey(tenant), Json.stringify(Json.toJson(record)))
          )
        }
        kafkaProducer.flush()
        batch
      } recoverWith {
        case ex ⇒ Failure(new KafkaProducerException(s"Failed to publish $topic message, to kafka queue.", ex))
      }
    }

    def sendWrapped(batch: Seq[KafkaMember], tenant: String): Try[Seq[KafkaMember]] = {
      val topic = topicResolver(tenant)
      Try {
        batch foreach { record ⇒
          kafkaProducer.send(
            new ProducerRecord[String, String](topic, record.generateKey(tenant), Json.stringify(Json.toJson(record)))
          )
        }
        kafkaProducer.flush()
        batch
      } recoverWith {
        case ex ⇒ Failure(new KafkaProducerException(s"Failed to publish $topic message, to kafka queue.", ex))
      }
    }
  }
}
