/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.1-dev
 */

package controllers

import javax.inject.Inject
import javax.inject.Singleton

import play.api.mvc._
import play.api.libs.json._

import scala.concurrent.duration._
import scala.util.{Success, Failure}

import services.EchoesService

class EchoesController @Singleton @Inject() (service: EchoesService) extends Controller {
  import com.bryzek.apidoc.reference.api.v0.models._
  import com.bryzek.apidoc.reference.api.v0.models.json._
  import play.api.libs.concurrent.Execution.Implicits.defaultContext
  
  def get(
    foo: _root_.scala.Option[String] = None,
    optionalMessages: _root_.scala.Option[Seq[String]] = None,
    requiredMessages: Seq[String]
  ) = Action.async {  request =>
    service.get(request, foo, optionalMessages, requiredMessages).map(_ match {
      case Success(result) =>
        Ok(Json.toJson(result))
      case Failure(ex) =>
        InternalServerError(Json.toJson(Error("500", ex.toString)))
    })
  }

  def getArraysOnly(
    optionalMessages: _root_.scala.Option[Seq[String]] = None,
    requiredMessages: Seq[String]
  ) = Action.async {  request =>
    service.get(request, optionalMessages, requiredMessages).map(_ match {
      case Success(result) =>
        Ok(Json.toJson(result))
      case Failure(ex) =>
        InternalServerError(Json.toJson(Error("500", ex.toString)))
    })
  }

  private def errorResponse[A: Writes](errors: JsError, create: String => A): Future[Result] = {
    val msg = errors.errors.map(node => {
      val nodeName = node._1.path.map(_.toString + ": ").mkString
      val message = node._2.map(_.message).mkString
      s"$nodeName$message"
    }).mkString(", ")
    scala.concurrent.Future(InternalServerError(Json.toJson(create(msg))))
  }

  private def errorResponse[A: Writes](ex: Throwable, create: String => A): Result =
    InternalServerError(Json.toJson(create(ex.getMessage)))

}
