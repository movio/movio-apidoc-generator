/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.1-dev
 */

package controllers

import javax.inject.Inject
import javax.inject.Singleton

import play.api.libs.json._

import scala.concurrent.duration._
import scala.concurrent.Future

import services.MembersService

import movio.cinema.error.core.v0.models._

class MembersController @Singleton @Inject() (service: MembersService) extends play.api.mvc.Controller {
  import com.bryzek.apidoc.reference.api.v0.models._
  import com.bryzek.apidoc.reference.api.v0.models.json._
  import play.api.libs.concurrent.Execution.Implicits.defaultContext
  
  def post(
    guid: _root_.java.util.UUID,
    organization: _root_.java.util.UUID,
    user: _root_.java.util.UUID,
    role: String
  ) = play.api.mvc.Action.async {  request =>
    service.post(request, guid, organization, user, role).map{_ match {
      case scala.util.Success(result) =>
        Ok(Json.toJson(result))
      case scala.util.Failure(ex) =>
        errorResponse(ex, msg => CustomError("500", msg))
    }}
  }

  def get(
    guid: _root_.scala.Option[_root_.java.util.UUID] = None,
    organizationGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
    userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
    role: _root_.scala.Option[String] = None
  ) = play.api.mvc.Action.async {  request =>
    service.get(request, guid, organizationGuid, userGuid, role).map{_ match {
      case scala.util.Success(result) =>
        Ok(Json.toJson(result))
      case scala.util.Failure(ex) =>
        errorResponse(ex, msg => CustomError("500", msg))
    }}
  }

  def getByOrganization(
    organization: _root_.java.util.UUID
  ) = play.api.mvc.Action.async {  request =>
    service.get(request, organization).map{_ match {
      case scala.util.Success(result) =>
        Ok(Json.toJson(result))
      case scala.util.Failure(ex) =>
        errorResponse(ex, msg => CustomError("500", msg))
    }}
  }

  def postMembersBulkByOrganization(
    organization: _root_.java.util.UUID
  ) = play.api.mvc.Action.async(play.api.mvc.BodyParsers.parse.json) {  request =>
    request.body.validate[Seq[com.bryzek.apidoc.reference.api.v0.models.Member]] match {
      case errors: JsError =>
        errorResponse(errors, msg => CustomError("500", msg))
      case body: JsSuccess[Seq[com.bryzek.apidoc.reference.api.v0.models.Member]] =>
        service.post(request, body.get, organization).map{_ match {
          case scala.util.Success(result) =>
            Ok(Json.toJson(result.size))
          case scala.util.Failure(ex) =>
            errorResponse(ex, msg => CustomError("500", msg))
        }}
    }
  }

  def postMembersMapByOrganization(
    organization: _root_.java.util.UUID
  ) = play.api.mvc.Action.async(play.api.mvc.BodyParsers.parse.json) {  request =>
    request.body.validate[Map[String, com.bryzek.apidoc.reference.api.v0.models.Member]] match {
      case errors: JsError =>
        errorResponse(errors, msg => CustomError("500", msg))
      case body: JsSuccess[Map[String, com.bryzek.apidoc.reference.api.v0.models.Member]] =>
        service.post(request, body.get, organization).map{_ match {
          case scala.util.Success(result) =>
            Ok(Json.toJson(result.size))
          case scala.util.Failure(ex) =>
            errorResponse(ex, msg => CustomError("500", msg))
        }}
    }
  }

  private def errorResponse[A: Writes](errors: JsError, create: String => A): Future[play.api.mvc.Result] = {
    val msg = errors.errors.flatMap(node => {
      val nodeName = node._1.path.map(_.toString + ": ").mkString
      val message = node._2.map(_.message).mkString
      s"$nodeName$message"
    }).mkString
    scala.concurrent.Future(InternalServerError(Json.toJson(create(msg))))
  }

  private def errorResponse[A: Writes](ex: Throwable, create: String => A): play.api.mvc.Result =
    InternalServerError(Json.toJson(create(ex.getMessage)))

}
