/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 1.0.0
 */

import kafka.producer._
import kafka.serializer.StringEncoder

import play.api.libs.json.Json
import play.api.libs.json.Writes

import java.util.Properties
import com.typesafe.config.Config

import movio.api.kafka_0_8.KafkaProducer
import movio.api.kafka_0_8.KafkaProducerException
import movio.core.utils.TryHelpers.TryOps

package test.apidoc.apidoctest.v0.kafka {
  import test.apidoc.apidoctest.v0.models._
  import test.apidoc.apidoctest.v0.models.json._

  object KafkaMemberProducer {
    val base = "test.apidoc.apidoctest.kafka.producer"
    val BrokerListKey = s"$base.broker-connection-string"
    val TopicInstanceKey = s"$base.topic-instance"
  }

  class KafkaMemberProducer(
    config: Config,
    topicResolver: String => String = KafkaMemberTopic.topic
  ) extends KafkaProducer[KafkaMember, Member] {
    import KafkaMemberProducer._

    lazy val topicResolver = KafkaMemberTopic.topic(config.getString(TopicInstanceKey))(_)

    lazy val producerConfig = new ProducerConfig(readProducerPropertiesFromConfig(config))
    lazy val producer = new Producer[String, String](producerConfig)


    def readProducerPropertiesFromConfig(config: Config) = {
      val properties = new Properties
      properties.put("producer.type", "sync")
      properties.put("metadata.broker.list", config.getString(BrokerListKey))
      properties.put("request.required.acks", "-1")
      properties.put("serializer.class", classOf[StringEncoder].getName)
      properties
    }

    def send(single: Member, tenant: String): scala.util.Try[Member] = {
      send(Seq(single), tenant).map(_.head)
    }

    def sendWrapped(single: KafkaMember, tenant: String): scala.util.Try[KafkaMember] = {
      sendWrapped(Seq(single), tenant).map(_.head)
    }

    def send(batch: Seq[Member], tenant: String): scala.util.Try[Seq[Member]] = {
      val topic = topicResolver(tenant)
      val messages = batch.map(KafkaMember(_))
      scala.util.Try {
        producer.send(messages map { message =>
                        new KeyedMessage[String, String](topic, message.generateKey(tenant), Json.stringify(Json.toJson(message)))
                      }: _*)
        batch
      } recoverWith {
        case ex => scala.util.Failure(new KafkaProducerException(s"Failed to publish $topic message, to kafka queue.", ex))
      }
    }

    def sendWrapped(batch: Seq[KafkaMember], tenant: String): scala.util.Try[Seq[KafkaMember]] = {
      val topic = topicResolver(tenant)
      scala.util.Try {
        producer.send(batch map { message =>
                        new KeyedMessage[String, String](topic, message.generateKey(tenant), Json.stringify(Json.toJson(message)))
                      }: _*)
        batch
      } recoverWith {
        case ex => scala.util.Failure(new KafkaProducerException(s"Failed to publish $topic message, to kafka queue.", ex))
      }
    }

    def shutdown() = producer.close()
  }

}
